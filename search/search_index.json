{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dmenv: simple and practical virtual environment manager for Python \u00b6 What it does \u00b6 dmenv takes care of: Creating virtual environments for you: one virtual environment per project and Python version, thus enforcing some commonly agreed-upon best practices Generating a lock file that contains all the versions of all your dependencies at a given time, so you can have reproducible builds If does it by: reading information about your project in the setup.py file and nothing else using already existing tools such as python3 -m venv and pip Want to try it? Proceed to installation and usage .","title":"Home"},{"location":"#dmenv_simple_and_practical_virtual_environment_manager_for_python","text":"","title":"dmenv: simple and practical virtual environment manager for Python"},{"location":"#what_it_does","text":"dmenv takes care of: Creating virtual environments for you: one virtual environment per project and Python version, thus enforcing some commonly agreed-upon best practices Generating a lock file that contains all the versions of all your dependencies at a given time, so you can have reproducible builds If does it by: reading information about your project in the setup.py file and nothing else using already existing tools such as python3 -m venv and pip Want to try it? Proceed to installation and usage .","title":"What it does"},{"location":"advanced_usage/","text":"Advanced Usage \u00b6 Some definitions \u00b6 Let's assume the following setup.cfg : [metadata] name = foo version = 0.1.0 [options] install_requires= path.py [options.extras_require] dev = pytest Since pytest is only used by the tests, and not the rest of the code, path.py is a regular dependency , and pytest is a development dependency . Now let's assume you've run dmenv lock and that the following lock file was produced: # requirements.lock path-py==11.4.0 importlib-metadata==0.5 pytest==3.9.0 py==1.6.0 importlib-metadata and py are dependencies of path.py and pytest respectively, and their version got \"frozen\" in the lock file. To differentiate those dependencies from the rest, we say that pytest and path.py are abstract , and than importlib-metadata and py are concrete . Note that if you publish your code on pypi.org, consumers of your package will only see the abstract , regular dependencies, so be careful with the install_requires section of the setup.cfg ! How the lock command works \u00b6 The requirements.lock is obtained by parsing the output of pip freeze , and thus is only a reflection of the state of the virtual environment from which pip was run. That means the result of the lock depends of something \"stateful\" that can change independently of the contents of the setup.cfg . For instance, if you run dmenv lock in a empty virtual environment, every concrete dependency gets frozen to their latest compatible version. On the other hand, if you run dmenv lock from a virtual environment that already contains foo , the foo version won't change (unless something in the setup.cfg causes it to change). This may seem like an horrible bug but, as we'll see in the next section, it makes it possible to use various interesting workflows when upgrading dependencies. Two features of dmenv make this work: One, both setup.cfg and requirements.lock can be edited by hand. Two, when the lock file already exists, dmenv lock \"applies\" the result of pip freeze to the existing lock file, and thus can preserve manual changes. Let's see some examples. Upgrade all the things! \u00b6 The simplest way is to just re-run dmenv lock after having cleaned the virtual environment. Runinng dmenv show:outdated allows you to have a preview of the upgrades first. $ dmenv show:outdated $ dmenv clean $ dmenv lock That way, all existing dependencies from the requirements.lock will get ignored, and you'll get the latest version of every concrete dependency. Give it a go, it often works better than you might think :) If something breaks (for instance when going from path.py 11.4 to path.py 11.5), you can edit the setup.cfg to specify that you are not compatible with the latest version of path.py: [options] install_requires= path.py < 11.5 Re-generating a clean lock \u00b6 You can force the re-creation of a clean lock by running: $ dmenv tidy This will: Clean the existing virtualenv Re-install dependencies listed in the setup.cfg file, constainted by the existing lock file Re-generate the lock file by only keeping dependencies that exist in the virtualenv This is better than running dmenv clean && dmenv lock because existing concrete dependencies won't be updated - see the section above if this is what you want. Freeze dev dependencies \u00b6 The above approach does not work really well if you use a linter like pylint or flake8 , of even a type checker like mypy This is because new releases of those tools often cause new warnings or errors to be produced, so you only want to update them when you're ready. Thus, a good practice is to freeze the versions of those tools directly in the `setup.cfg: [options.extras_require] dev = flake8==3.5.0 That way you can freely re-run dmenv lock , even in a completely fresh environment. Upgrading just one development dependency \u00b6 For instance if there's a bug in py , you can bump py version by editing the lock file directly: - py==1.6.0 + py==1.7.0 Upgrading just one regular dependency \u00b6 If the bug is in one of the concrete dependencies, you should update the setup.cfg file instead install_requires=[ \"path.py\" + \"importlib-metadata >= 0.6\" ] That way consumers of your code will get the correct version. Then run dmenv lock without cleaning the virtual environment so that importlib-metadata gets upgraded and its new version frozen. Using dependencies from git URLs \u00b6 Let's say you came across a bug that's only fixed on the master branch of pytest on GitHub, specifically at the commit deadbeef . One solution is to replace the line in requirements.lock to use a git URL like this: # requirements git+https://github.com/pytest-dev/pytest@deadbeef#egg=pytest In that case, pip freeze will contain a line looking like pytest==4.0b1 , where 4.0b1 is the pytest version at this particular commit. When it comes to re-generating the lock, dmenv will see that there is already a line specifying the pytest version in a more precise manner, so it will keep the git line in the lock and ignore the non-precise 4.0b1 version. Using dependencies only for a given platform \u00b6 Sometimes a concrete dependency will only be available on a specify platform. So if you've generated the lock file on Linux, you may get different results on Windows. One way to solve this is to run dmenv lock with the --platfrom argument. Existing lines in the lock file will be kept, and any new dependency will be suffixed with a platform marker , like this: # requirements.lock, generated on liux foo==0.2 > dmenv lock --platform windows # run on Windows # requirements.lock foo==0.2 pywin2==0.42 ; platform == \"windows\" Using dependencies only for a given Python version \u00b6 If you want your code to be run across different Python versions, you may encounter similar issues. Sometimes one of your concrete dependency will only be required for old interpreters. For instance, the pathlib2 package is only useful for 3.5 and below. After that you simply use the standard library. In than case, you can specify a python version requirement, like this: # requirements.lock , generated with Python 3.6 foo==0.2 $ dmenv lock --python '< \"3.5\"' <- note the quotes # requirements.lock foo==0.2 bar==0.42 ; python_version < \"3.5\" Skipping development dependencies \u00b6 Sometimes you will want to skip development dependencies. In this case, prefix your dmenv command with a --production flag, like so: $ dmenv --production lock $ dmenv --production install Note that both the location of the virtual environment and the lock file will be different. You can also specify dependencies just for production, by using an extra requirement named prod : setup( ... extras_require={ \"dev\": [\"foo\", \"pytest\"], \"prod\": [\"foo-prod\"], } ) Allowing access to Python packages from the system \u00b6 Use dmenv --system-site-packages install and/or dmenv --system-site-packages lock to create a virtual environment that has access to the system's site packages. In the latter case, dependencies outside the virtual environment are not included in the lock file. Specifying the interpreter binary \u00b6 By default, dmenv uses the following algorithm to find the Python binary: Look for a program named python3 in the PATH environment variable If nothing is found, look for a program named python Otherwise, fail You can use dmenv --python /path/to/other/binary to specify the full path to the Python binary. Combining pyenv and dmenv \u00b6 pyenv is a generic tool to manage several Python installations on the same machine. Here's how you can combine the too, for instance to check if your project is compatible with both Python3.7 and Python3.8, and assuming the \"system\" python is 3.7. First, use pyenv to compile and install Python 3.8 from sources $ pyenv install 3.8.0 Then you can switch Python versions by setting the PYENV_VERSION environment variable when using dmenv . $ dmenv install # Nothing set, creates a virtual environment for 3.7 in .venv/dev/3.7.4 $ PYENV_VERSION=3.8.0 dmenv install # Creates a Python3.8 compatible virtualenv in .venv/dev/3.8.0","title":"Advanced Usage"},{"location":"advanced_usage/#advanced_usage","text":"","title":"Advanced Usage"},{"location":"advanced_usage/#some_definitions","text":"Let's assume the following setup.cfg : [metadata] name = foo version = 0.1.0 [options] install_requires= path.py [options.extras_require] dev = pytest Since pytest is only used by the tests, and not the rest of the code, path.py is a regular dependency , and pytest is a development dependency . Now let's assume you've run dmenv lock and that the following lock file was produced: # requirements.lock path-py==11.4.0 importlib-metadata==0.5 pytest==3.9.0 py==1.6.0 importlib-metadata and py are dependencies of path.py and pytest respectively, and their version got \"frozen\" in the lock file. To differentiate those dependencies from the rest, we say that pytest and path.py are abstract , and than importlib-metadata and py are concrete . Note that if you publish your code on pypi.org, consumers of your package will only see the abstract , regular dependencies, so be careful with the install_requires section of the setup.cfg !","title":"Some definitions"},{"location":"advanced_usage/#how_the_lock_command_works","text":"The requirements.lock is obtained by parsing the output of pip freeze , and thus is only a reflection of the state of the virtual environment from which pip was run. That means the result of the lock depends of something \"stateful\" that can change independently of the contents of the setup.cfg . For instance, if you run dmenv lock in a empty virtual environment, every concrete dependency gets frozen to their latest compatible version. On the other hand, if you run dmenv lock from a virtual environment that already contains foo , the foo version won't change (unless something in the setup.cfg causes it to change). This may seem like an horrible bug but, as we'll see in the next section, it makes it possible to use various interesting workflows when upgrading dependencies. Two features of dmenv make this work: One, both setup.cfg and requirements.lock can be edited by hand. Two, when the lock file already exists, dmenv lock \"applies\" the result of pip freeze to the existing lock file, and thus can preserve manual changes. Let's see some examples.","title":"How the lock command works"},{"location":"advanced_usage/#upgrade_all_the_things","text":"The simplest way is to just re-run dmenv lock after having cleaned the virtual environment. Runinng dmenv show:outdated allows you to have a preview of the upgrades first. $ dmenv show:outdated $ dmenv clean $ dmenv lock That way, all existing dependencies from the requirements.lock will get ignored, and you'll get the latest version of every concrete dependency. Give it a go, it often works better than you might think :) If something breaks (for instance when going from path.py 11.4 to path.py 11.5), you can edit the setup.cfg to specify that you are not compatible with the latest version of path.py: [options] install_requires= path.py < 11.5","title":"Upgrade all the things!"},{"location":"advanced_usage/#re-generating_a_clean_lock","text":"You can force the re-creation of a clean lock by running: $ dmenv tidy This will: Clean the existing virtualenv Re-install dependencies listed in the setup.cfg file, constainted by the existing lock file Re-generate the lock file by only keeping dependencies that exist in the virtualenv This is better than running dmenv clean && dmenv lock because existing concrete dependencies won't be updated - see the section above if this is what you want.","title":"Re-generating a clean lock"},{"location":"advanced_usage/#freeze_dev_dependencies","text":"The above approach does not work really well if you use a linter like pylint or flake8 , of even a type checker like mypy This is because new releases of those tools often cause new warnings or errors to be produced, so you only want to update them when you're ready. Thus, a good practice is to freeze the versions of those tools directly in the `setup.cfg: [options.extras_require] dev = flake8==3.5.0 That way you can freely re-run dmenv lock , even in a completely fresh environment.","title":"Freeze dev dependencies"},{"location":"advanced_usage/#upgrading_just_one_development_dependency","text":"For instance if there's a bug in py , you can bump py version by editing the lock file directly: - py==1.6.0 + py==1.7.0","title":"Upgrading just one development dependency"},{"location":"advanced_usage/#upgrading_just_one_regular_dependency","text":"If the bug is in one of the concrete dependencies, you should update the setup.cfg file instead install_requires=[ \"path.py\" + \"importlib-metadata >= 0.6\" ] That way consumers of your code will get the correct version. Then run dmenv lock without cleaning the virtual environment so that importlib-metadata gets upgraded and its new version frozen.","title":"Upgrading just one regular dependency"},{"location":"advanced_usage/#using_dependencies_from_git_urls","text":"Let's say you came across a bug that's only fixed on the master branch of pytest on GitHub, specifically at the commit deadbeef . One solution is to replace the line in requirements.lock to use a git URL like this: # requirements git+https://github.com/pytest-dev/pytest@deadbeef#egg=pytest In that case, pip freeze will contain a line looking like pytest==4.0b1 , where 4.0b1 is the pytest version at this particular commit. When it comes to re-generating the lock, dmenv will see that there is already a line specifying the pytest version in a more precise manner, so it will keep the git line in the lock and ignore the non-precise 4.0b1 version.","title":"Using dependencies from git URLs"},{"location":"advanced_usage/#using_dependencies_only_for_a_given_platform","text":"Sometimes a concrete dependency will only be available on a specify platform. So if you've generated the lock file on Linux, you may get different results on Windows. One way to solve this is to run dmenv lock with the --platfrom argument. Existing lines in the lock file will be kept, and any new dependency will be suffixed with a platform marker , like this: # requirements.lock, generated on liux foo==0.2 > dmenv lock --platform windows # run on Windows # requirements.lock foo==0.2 pywin2==0.42 ; platform == \"windows\"","title":"Using dependencies only for a given platform"},{"location":"advanced_usage/#using_dependencies_only_for_a_given_python_version","text":"If you want your code to be run across different Python versions, you may encounter similar issues. Sometimes one of your concrete dependency will only be required for old interpreters. For instance, the pathlib2 package is only useful for 3.5 and below. After that you simply use the standard library. In than case, you can specify a python version requirement, like this: # requirements.lock , generated with Python 3.6 foo==0.2 $ dmenv lock --python '< \"3.5\"' <- note the quotes # requirements.lock foo==0.2 bar==0.42 ; python_version < \"3.5\"","title":"Using dependencies only for a given Python version"},{"location":"advanced_usage/#skipping_development_dependencies","text":"Sometimes you will want to skip development dependencies. In this case, prefix your dmenv command with a --production flag, like so: $ dmenv --production lock $ dmenv --production install Note that both the location of the virtual environment and the lock file will be different. You can also specify dependencies just for production, by using an extra requirement named prod : setup( ... extras_require={ \"dev\": [\"foo\", \"pytest\"], \"prod\": [\"foo-prod\"], } )","title":"Skipping development dependencies"},{"location":"advanced_usage/#allowing_access_to_python_packages_from_the_system","text":"Use dmenv --system-site-packages install and/or dmenv --system-site-packages lock to create a virtual environment that has access to the system's site packages. In the latter case, dependencies outside the virtual environment are not included in the lock file.","title":"Allowing access to Python packages from the system"},{"location":"advanced_usage/#specifying_the_interpreter_binary","text":"By default, dmenv uses the following algorithm to find the Python binary: Look for a program named python3 in the PATH environment variable If nothing is found, look for a program named python Otherwise, fail You can use dmenv --python /path/to/other/binary to specify the full path to the Python binary.","title":"Specifying the interpreter binary"},{"location":"advanced_usage/#combining_pyenv_and_dmenv","text":"pyenv is a generic tool to manage several Python installations on the same machine. Here's how you can combine the too, for instance to check if your project is compatible with both Python3.7 and Python3.8, and assuming the \"system\" python is 3.7. First, use pyenv to compile and install Python 3.8 from sources $ pyenv install 3.8.0 Then you can switch Python versions by setting the PYENV_VERSION environment variable when using dmenv . $ dmenv install # Nothing set, creates a virtual environment for 3.7 in .venv/dev/3.7.4 $ PYENV_VERSION=3.8.0 dmenv install # Creates a Python3.8 compatible virtualenv in .venv/dev/3.8.0","title":"Combining pyenv and dmenv"},{"location":"basic_usage/","text":"Usage \u00b6 A note about setup.py and setup.cfg \u00b6 The following documentation assumes you are calling setuptools.setup() with no arguments and that all of setuptools options are set in the setup.cfg file. See setuptools documentation for more details. dmenv will still work otherwise, but please bear in mind that you will have to adapt the code samples below. Setup \u00b6 First, dmenv needs a Python3 interpreter in PATH, which should be called python or python3 . This is usually the case if you've just installed Python3, regardless of your operating system. Second, dmenv needs a setup.py file to work. If you don't have a setup.py yet, you can run dmenv init <project name> to generate one, alongside a setup.cfg file. In this case, make sure to read the comments inside and edit it to fit your needs. If you already have a setup.py or a setup.cfg file that contains info about dependencies, please note that dmenv uses \"extras require\" dependencies to specify development dependencies, under the dev key. You are now ready to use dmenv . Keep on reading about the two main commands: dmenv lock and dmenv install . dmenv lock \u00b6 Here's what dmenv lock does: It looks for a binary named python3 or python in the PATH environment variable. It runs a bit of Python code to determine the interpreter version (3.6, 3.7 ...). Then, it creates a virtual environment in .venv/dev/<version> using python -m venv . (This step is skipped if dmenv detects it is run from an existing virtual environment). Note that you may have to configure other tools to ignore this directory. Then it runs pip install --editable .[dev] so that your dev dependencies are installed, and the scripts listed in entry_points are created. Finally, it runs pip freeze to generate a requirements.lock file. Now you can add the requirements.lock file to your version control system. This leads us to the next command: dmenv install \u00b6 Now that the complete list of dependencies and their versions is written in the requirements.lock file, anyone can run dmenv install to install all the dependencies and get exactly the same versions you got when you ran dmenv lock . Hooray reproducible builds! dmenv run \u00b6 One the virtual environment has been created, you can run any binary from the venv with the command dmenv run . For instance, assuming pytest is declared as a dependency: $ dmenv run pytest Note that you can also use dmenv run to run scripts from your project: $ dmenv run foo.py # Equivalent to: $ dmenv run python foo.py Configuring other tools \u00b6 Depending of your usage, you may need to tell other tools to ignore the .venv directory. git : add a line containing .venv/ to the .gitignore . # should be already there if you use # setup.py *.egg-info build/ dist/ # only directory in which `dmenv` will write files: .venv/ pyflakes , pylint and other linters: add some configuration in the setup.cfg file: exclude = .venv As an alternative, you can also ask dmenv to create its virtual environment outside your project, by setting the DMENV_VENV_OUTSIDE_PROJECT environment variable to a non-empty value like 1 . It will then use the app_dirs crate as a location to store the created virtual environments. Upgrading dmenv \u00b6 If you have wget installed and used a pre-compiled binary, upgrading dmenv can be done in just one command: # Replace <version> and <arch> with their correct value $ wget \\ https://github.com/TankerHQ/dmenv/releases/download/v<version>/dmenv-<arch> \\ -O $(which dmenv) If you've installed dmenv from source: rustup update stable # dmenv usually requires latest rust stable version cargo install --force dmenv Adding a new dependency \u00b6 This process is in two parts. First, add the dependency in setup.cfg or setup.py , in the install_requires section. Then, run dmenv lock to update the corresponding lock file . The process changes lightly if you are working with a development dependency, or a dependency that is only used for production. See the advanced usage section for details. Upgrading a top-level dependency \u00b6 Let's say your project depends on foolib . Version 1.3 works fine, but 1.4 just came out and even if you don't need any new feature from 1.4 , you'd like to check wether your project is compatible. 1 Assuming you already have a virtual environment containing foolib 1.3 , you can can do so by running: $ git status # check that requirements.lock is clean $ dmenv run -- pip install --upgrade foolib Most of the time, pip install --upgrade foolib will do the right thing: it will keep other dependencies installed at their current version it will install new dependencies of foolib 1.4 if they are missing if foolib 1.4 contains a bar >= 3.0 constraint and you have bar == 2.0 in the virtualenv, bar will be upgraded too. Then it's time to register the new dependencies in the lock: $ dmenv lock You can now inspect the differences in the lock file by hand, and if they are correct, commit and push a new version of the lock file. Going further \u00b6 That's all for the basic usage of dmenv , you may proceed to the goodies section or read on about advanced dmenv usage If you do need foolib in version 1.4 or later, you should express this constraint in the setup.py file instead, as explained in the upgrading just one regular dependency section. \u21a9","title":"Basic Usage"},{"location":"basic_usage/#usage","text":"","title":"Usage"},{"location":"basic_usage/#a_note_about_setuppy_and_setupcfg","text":"The following documentation assumes you are calling setuptools.setup() with no arguments and that all of setuptools options are set in the setup.cfg file. See setuptools documentation for more details. dmenv will still work otherwise, but please bear in mind that you will have to adapt the code samples below.","title":"A note about setup.py and setup.cfg"},{"location":"basic_usage/#setup","text":"First, dmenv needs a Python3 interpreter in PATH, which should be called python or python3 . This is usually the case if you've just installed Python3, regardless of your operating system. Second, dmenv needs a setup.py file to work. If you don't have a setup.py yet, you can run dmenv init <project name> to generate one, alongside a setup.cfg file. In this case, make sure to read the comments inside and edit it to fit your needs. If you already have a setup.py or a setup.cfg file that contains info about dependencies, please note that dmenv uses \"extras require\" dependencies to specify development dependencies, under the dev key. You are now ready to use dmenv . Keep on reading about the two main commands: dmenv lock and dmenv install .","title":"Setup"},{"location":"basic_usage/#dmenv_lock","text":"Here's what dmenv lock does: It looks for a binary named python3 or python in the PATH environment variable. It runs a bit of Python code to determine the interpreter version (3.6, 3.7 ...). Then, it creates a virtual environment in .venv/dev/<version> using python -m venv . (This step is skipped if dmenv detects it is run from an existing virtual environment). Note that you may have to configure other tools to ignore this directory. Then it runs pip install --editable .[dev] so that your dev dependencies are installed, and the scripts listed in entry_points are created. Finally, it runs pip freeze to generate a requirements.lock file. Now you can add the requirements.lock file to your version control system. This leads us to the next command:","title":"dmenv lock"},{"location":"basic_usage/#dmenv_install","text":"Now that the complete list of dependencies and their versions is written in the requirements.lock file, anyone can run dmenv install to install all the dependencies and get exactly the same versions you got when you ran dmenv lock . Hooray reproducible builds!","title":"dmenv install"},{"location":"basic_usage/#dmenv_run","text":"One the virtual environment has been created, you can run any binary from the venv with the command dmenv run . For instance, assuming pytest is declared as a dependency: $ dmenv run pytest Note that you can also use dmenv run to run scripts from your project: $ dmenv run foo.py # Equivalent to: $ dmenv run python foo.py","title":"dmenv run"},{"location":"basic_usage/#configuring_other_tools","text":"Depending of your usage, you may need to tell other tools to ignore the .venv directory. git : add a line containing .venv/ to the .gitignore . # should be already there if you use # setup.py *.egg-info build/ dist/ # only directory in which `dmenv` will write files: .venv/ pyflakes , pylint and other linters: add some configuration in the setup.cfg file: exclude = .venv As an alternative, you can also ask dmenv to create its virtual environment outside your project, by setting the DMENV_VENV_OUTSIDE_PROJECT environment variable to a non-empty value like 1 . It will then use the app_dirs crate as a location to store the created virtual environments.","title":"Configuring other tools"},{"location":"basic_usage/#upgrading_dmenv","text":"If you have wget installed and used a pre-compiled binary, upgrading dmenv can be done in just one command: # Replace <version> and <arch> with their correct value $ wget \\ https://github.com/TankerHQ/dmenv/releases/download/v<version>/dmenv-<arch> \\ -O $(which dmenv) If you've installed dmenv from source: rustup update stable # dmenv usually requires latest rust stable version cargo install --force dmenv","title":"Upgrading dmenv"},{"location":"basic_usage/#adding_a_new_dependency","text":"This process is in two parts. First, add the dependency in setup.cfg or setup.py , in the install_requires section. Then, run dmenv lock to update the corresponding lock file . The process changes lightly if you are working with a development dependency, or a dependency that is only used for production. See the advanced usage section for details.","title":"Adding a new dependency"},{"location":"basic_usage/#upgrading_a_top-level_dependency","text":"Let's say your project depends on foolib . Version 1.3 works fine, but 1.4 just came out and even if you don't need any new feature from 1.4 , you'd like to check wether your project is compatible. 1 Assuming you already have a virtual environment containing foolib 1.3 , you can can do so by running: $ git status # check that requirements.lock is clean $ dmenv run -- pip install --upgrade foolib Most of the time, pip install --upgrade foolib will do the right thing: it will keep other dependencies installed at their current version it will install new dependencies of foolib 1.4 if they are missing if foolib 1.4 contains a bar >= 3.0 constraint and you have bar == 2.0 in the virtualenv, bar will be upgraded too. Then it's time to register the new dependencies in the lock: $ dmenv lock You can now inspect the differences in the lock file by hand, and if they are correct, commit and push a new version of the lock file.","title":"Upgrading a top-level dependency"},{"location":"basic_usage/#going_further","text":"That's all for the basic usage of dmenv , you may proceed to the goodies section or read on about advanced dmenv usage If you do need foolib in version 1.4 or later, you should express this constraint in the setup.py file instead, as explained in the upgrading just one regular dependency section. \u21a9","title":"Going further"},{"location":"changelog/","text":"0.20.0 (2019-11-12) \u00b6 Do not change the working directory when creating a virtual environment. This makes combining dmenv and pyenv much easier. Add dmenv create command to create an empty virtual environment. 0.19.0 (2019-O6-11) \u00b6 Breaking : the --system-site-packages option must be passed before any subcommand, and the path of the virtual environment has changed: <= 0.18 : $ dmenv install --system-site-packages # virtual environment created in .venv/dev/3.7/ >= 0.19 : $ dmenv --system-site-packages install # virtual environment created in .venv/dev-system/3.7/ Fix #110: dmenv tidy now works even from an activated virtual environment. 0.18.0 (2019-29-10) \u00b6 Add a tidy command, to re-generate locks from a clean virtual environment. 0.17.0 (2019-10-08) \u00b6 Add a process-scripts command, to generate scripts in DMENV_SCRIPTS_PATH . 0.16.2 (2019-10-03) \u00b6 Fix regression: dmenv init could only be used with the --project option Improve error messages when setup.py or requirements.lock is not found Improve error handling when parsing output from info.py Fix message when using dmenv --production install 0.16.1 (2019-07-24) \u00b6 Fix regression that caused parsing output of dmenv show commands to stop working 0.16.0 (2019-07-24) \u00b6 Fix #94: Look for setup.py in the parent directories when trying to resolve the project path. 0.15.0 (2019-06-26) \u00b6 When foo.py is present at the root of the project, you can us dmenv run foo.py directly instead of the more awkward dmenv run -- python foo.py 0.14.3 (2019-05-15) \u00b6 Fix syntax of generated setup.py (#86) Fix regression: keep the top comment when running bump-in-lock 0.14.2 (2019-04-29) \u00b6 Restore generation of pre-compiled binaries from travis. 0.14.1 (2019-04-29) \u00b6 Fix incorrect --help message Better error handling when the virtual environment or binary path do not exist Fix typo in setup.cfg template All reported by @theodelrieu. Thanks, man. 0.14.0 (2019-04-05) \u00b6 Breaking: dmenv init now uses a separate setup.cfg file alongside setup.py \u00b6 This leads to far more readable code. Note: this may break when using setuptools <= 30.3.0 (roughly Python 3.5). Use dmenv init --no-setup-cfg if you need compatibility with old Python versions. 0.13.0 (2019-04-03) \u00b6 Implement #77 : Add a new --production flag to use prod extra requirements instead of dev . This allows having dependencies just for production environments. 0.12.0 (2018-03-20) \u00b6 Show outdated dependencies \u00b6 Use dmenv show:outdated to show outdated dependencies. Allow access to system site packages \u00b6 dmenv install and dmenv lock commands learned the --system-site-packages option to create virtual environments that have access to packages installed globally on the system. Allow skipping development dependencies \u00b6 This is done with the --production flag. For instance, dmenv --production install . dmenv --production lock will create a production.lock that contains no development dependencies. Breaking changes \u00b6 Virtual environment location has changed to allow both production and full virtual environments to coexist: When using DMENV_VENV_OUTSIDE_PROJECT version location <= 0.11 DATA_DIR/dmenv/venv/3.7.1/foo/ >= 0.12, default DATA_DIR/dmenv/venv/dev/3.7.1/foo/ >= 0.12, with --production DATA_DIR/dmenv/venv/prod/3.7.1/foo/ Otherwise: version location <= 0.11 .venv/3.7.1/foo/ >= 0.12, default .venv/dev/3.7.1/foo/ >= 0.12, with --production .venv/prod/3.7.1/foo/ Migrating from 0.11 \u00b6 Run dmenv clean with dmenv 0.11 to clean up the deprecated location Upgrade to dmenv 0.12 Run dmenv install to create the new virtual environment 0.11.1 (2010-03-01) \u00b6 Fix metadata on Cargo to include new tagline. 0.11.0 (2019-02-20) \u00b6 Add dmenv show:bin_path to show the path of the virtual environment binaries. Breaking changes \u00b6 Fix #31 : make sure the wheel package gets frozen when running dmenv lock . Note: this also causes other packages like setuptools and pip itself to get frozen. As a consequence dmenv install no longer upgrades pip automatically, and so the --no-upgrade-pip option is gone. 0.10.0 (2019-01-30) \u00b6 Allow using dmenv outside the current project, by setting an environment variable named DMENV_VENV_OUTSIDE_PROJECT . 0.9.0 (2019-01-25) \u00b6 Fix #54 : rename --cwd option to --project . Avoid blindly overwriting the requirements.lock file when running. dmenv lock . See #11 and #7 for background. 0.8.4 (2019-01-15) \u00b6 Fix #49 : return code was always 0 when using dmenv run on Windows. (regression introduced in 0.8.1 ). 0.8.3 (2019-01-11) \u00b6 Add documentation link to Cargo.toml . 0.8.2 (2019-01-09) \u00b6 Fix #45 : dmenv env can be used with non-ASCII chars on Windows. 0.8.1 (2019-01-08) \u00b6 dmenv run now uses execv from libc . This means the child process is killed when killing dmenv . The previous behavior (starting a new process) can be activated with the --no-exec option. 0.8.0 (2018-12-21) \u00b6 Allow using python3 -m virtualenv instead of python3 -m venv to create the virtual environments by setting an environment variable named DMENV_NO_VENV_STDLIB . This can be used to work around some bugs in Debian-based distributions. 0.7.0 (2018-12-07) \u00b6 Add bump-in-lock command. Use to bump version or git references in the requirements.lock file. 0.6.0 (2018-11-09) \u00b6 Run setup.py develop with --no-deps . Rename show to show:venv_path , add show:deps to display the list of dependencies. 0.5.0 (2018-11-07) \u00b6 dmenv init : since name is required, it is now an argument, no longer an option. So instead of dmenv init --name foo --version 0.42 , use dmenv init foo --version 0.42 Add a command named dmenv develop that just runs python setup.py develop and nothing else. dmenv install : add --no-upgrade-pip and --no-develop options. 0.4.3 (2018-11-06) \u00b6 Add a --author option to dmenv init , used when generating the setup.py file. Fix #12 : dmenv lock now exits immediately if the lock file is missing. Workaround Debian bug in pip (See #15 for details). 0.4.2 (2018-11-05) \u00b6 Write some metadata inside the requirements.lock file. Improve dmenv run : Suggest running lock or install Do not crash if used without arguments 0.4.1 (2018-11-04) \u00b6 Fix CI on Windows. 0.4.0 (2018-11-03) \u00b6 dmenv no longer needs a configuration file. Find the Python interpreter to use by looking in the PATH environment variable. 0.3.4 (2018-11-03) \u00b6 Fix #9 : If dmenv is run inside an existing virtual environment , just use it. 0.3.3 (2018-11-03) \u00b6 Also upgrade pip when running dmenv install . Fix incorrect message when running dmenv lock . 0.3.2 (2018-11-03) \u00b6 Fix regression introduced in 0.3.1: create config path parent subdirectory before trying to write inside it. 0.3.1 (2018-11-03) \u00b6 Add a dmenv subdirectory to the configuration file path. 0.3.0 (2018-11-01) \u00b6 Replace command freeze by lock . 0.2.3 (2018-11-01) \u00b6 Add command dmenv init to generate a working setup.py file. 0.2.2 (2018-11-01) \u00b6 Fix running dmenv on Windows. The configuration file is now read from $HOME ( ~/.config on Linux and macOS, %HOME%\\AppData\\Local on Windows). 0.2.1 (2018-10-31) \u00b6 The .dmenv.toml file is now required. 0.2.0 (2018-10-31) \u00b6 Can be used with multiple python versions, using the .dmenv.toml config file. 0.1.0 (2018-10-31) \u00b6 Initial release.","title":"Changelog"},{"location":"changelog/#0200_2019-11-12","text":"Do not change the working directory when creating a virtual environment. This makes combining dmenv and pyenv much easier. Add dmenv create command to create an empty virtual environment.","title":"0.20.0 (2019-11-12)"},{"location":"changelog/#0190_2019-o6-11","text":"Breaking : the --system-site-packages option must be passed before any subcommand, and the path of the virtual environment has changed: <= 0.18 : $ dmenv install --system-site-packages # virtual environment created in .venv/dev/3.7/ >= 0.19 : $ dmenv --system-site-packages install # virtual environment created in .venv/dev-system/3.7/ Fix #110: dmenv tidy now works even from an activated virtual environment.","title":"0.19.0 (2019-O6-11)"},{"location":"changelog/#0180_2019-29-10","text":"Add a tidy command, to re-generate locks from a clean virtual environment.","title":"0.18.0 (2019-29-10)"},{"location":"changelog/#0170_2019-10-08","text":"Add a process-scripts command, to generate scripts in DMENV_SCRIPTS_PATH .","title":"0.17.0 (2019-10-08)"},{"location":"changelog/#0162_2019-10-03","text":"Fix regression: dmenv init could only be used with the --project option Improve error messages when setup.py or requirements.lock is not found Improve error handling when parsing output from info.py Fix message when using dmenv --production install","title":"0.16.2 (2019-10-03)"},{"location":"changelog/#0161_2019-07-24","text":"Fix regression that caused parsing output of dmenv show commands to stop working","title":"0.16.1 (2019-07-24)"},{"location":"changelog/#0160_2019-07-24","text":"Fix #94: Look for setup.py in the parent directories when trying to resolve the project path.","title":"0.16.0 (2019-07-24)"},{"location":"changelog/#0150_2019-06-26","text":"When foo.py is present at the root of the project, you can us dmenv run foo.py directly instead of the more awkward dmenv run -- python foo.py","title":"0.15.0 (2019-06-26)"},{"location":"changelog/#0143_2019-05-15","text":"Fix syntax of generated setup.py (#86) Fix regression: keep the top comment when running bump-in-lock","title":"0.14.3 (2019-05-15)"},{"location":"changelog/#0142_2019-04-29","text":"Restore generation of pre-compiled binaries from travis.","title":"0.14.2 (2019-04-29)"},{"location":"changelog/#0141_2019-04-29","text":"Fix incorrect --help message Better error handling when the virtual environment or binary path do not exist Fix typo in setup.cfg template All reported by @theodelrieu. Thanks, man.","title":"0.14.1 (2019-04-29)"},{"location":"changelog/#0140_2019-04-05","text":"","title":"0.14.0 (2019-04-05)"},{"location":"changelog/#breaking_dmenv_init_now_uses_a_separate_setupcfg_file_alongside_setuppy","text":"This leads to far more readable code. Note: this may break when using setuptools <= 30.3.0 (roughly Python 3.5). Use dmenv init --no-setup-cfg if you need compatibility with old Python versions.","title":"Breaking: dmenv init now uses a separate setup.cfg file alongside setup.py"},{"location":"changelog/#0130_2019-04-03","text":"Implement #77 : Add a new --production flag to use prod extra requirements instead of dev . This allows having dependencies just for production environments.","title":"0.13.0 (2019-04-03)"},{"location":"changelog/#0120_2018-03-20","text":"","title":"0.12.0 (2018-03-20)"},{"location":"changelog/#show_outdated_dependencies","text":"Use dmenv show:outdated to show outdated dependencies.","title":"Show outdated dependencies"},{"location":"changelog/#allow_access_to_system_site_packages","text":"dmenv install and dmenv lock commands learned the --system-site-packages option to create virtual environments that have access to packages installed globally on the system.","title":"Allow access to system site packages"},{"location":"changelog/#allow_skipping_development_dependencies","text":"This is done with the --production flag. For instance, dmenv --production install . dmenv --production lock will create a production.lock that contains no development dependencies.","title":"Allow skipping development dependencies"},{"location":"changelog/#breaking_changes","text":"Virtual environment location has changed to allow both production and full virtual environments to coexist: When using DMENV_VENV_OUTSIDE_PROJECT version location <= 0.11 DATA_DIR/dmenv/venv/3.7.1/foo/ >= 0.12, default DATA_DIR/dmenv/venv/dev/3.7.1/foo/ >= 0.12, with --production DATA_DIR/dmenv/venv/prod/3.7.1/foo/ Otherwise: version location <= 0.11 .venv/3.7.1/foo/ >= 0.12, default .venv/dev/3.7.1/foo/ >= 0.12, with --production .venv/prod/3.7.1/foo/","title":"Breaking changes"},{"location":"changelog/#migrating_from_011","text":"Run dmenv clean with dmenv 0.11 to clean up the deprecated location Upgrade to dmenv 0.12 Run dmenv install to create the new virtual environment","title":"Migrating from 0.11"},{"location":"changelog/#0111_2010-03-01","text":"Fix metadata on Cargo to include new tagline.","title":"0.11.1 (2010-03-01)"},{"location":"changelog/#0110_2019-02-20","text":"Add dmenv show:bin_path to show the path of the virtual environment binaries.","title":"0.11.0 (2019-02-20)"},{"location":"changelog/#breaking_changes_1","text":"Fix #31 : make sure the wheel package gets frozen when running dmenv lock . Note: this also causes other packages like setuptools and pip itself to get frozen. As a consequence dmenv install no longer upgrades pip automatically, and so the --no-upgrade-pip option is gone.","title":"Breaking changes"},{"location":"changelog/#0100_2019-01-30","text":"Allow using dmenv outside the current project, by setting an environment variable named DMENV_VENV_OUTSIDE_PROJECT .","title":"0.10.0 (2019-01-30)"},{"location":"changelog/#090_2019-01-25","text":"Fix #54 : rename --cwd option to --project . Avoid blindly overwriting the requirements.lock file when running. dmenv lock . See #11 and #7 for background.","title":"0.9.0 (2019-01-25)"},{"location":"changelog/#084_2019-01-15","text":"Fix #49 : return code was always 0 when using dmenv run on Windows. (regression introduced in 0.8.1 ).","title":"0.8.4 (2019-01-15)"},{"location":"changelog/#083_2019-01-11","text":"Add documentation link to Cargo.toml .","title":"0.8.3 (2019-01-11)"},{"location":"changelog/#082_2019-01-09","text":"Fix #45 : dmenv env can be used with non-ASCII chars on Windows.","title":"0.8.2 (2019-01-09)"},{"location":"changelog/#081_2019-01-08","text":"dmenv run now uses execv from libc . This means the child process is killed when killing dmenv . The previous behavior (starting a new process) can be activated with the --no-exec option.","title":"0.8.1 (2019-01-08)"},{"location":"changelog/#080_2018-12-21","text":"Allow using python3 -m virtualenv instead of python3 -m venv to create the virtual environments by setting an environment variable named DMENV_NO_VENV_STDLIB . This can be used to work around some bugs in Debian-based distributions.","title":"0.8.0 (2018-12-21)"},{"location":"changelog/#070_2018-12-07","text":"Add bump-in-lock command. Use to bump version or git references in the requirements.lock file.","title":"0.7.0 (2018-12-07)"},{"location":"changelog/#060_2018-11-09","text":"Run setup.py develop with --no-deps . Rename show to show:venv_path , add show:deps to display the list of dependencies.","title":"0.6.0 (2018-11-09)"},{"location":"changelog/#050_2018-11-07","text":"dmenv init : since name is required, it is now an argument, no longer an option. So instead of dmenv init --name foo --version 0.42 , use dmenv init foo --version 0.42 Add a command named dmenv develop that just runs python setup.py develop and nothing else. dmenv install : add --no-upgrade-pip and --no-develop options.","title":"0.5.0 (2018-11-07)"},{"location":"changelog/#043_2018-11-06","text":"Add a --author option to dmenv init , used when generating the setup.py file. Fix #12 : dmenv lock now exits immediately if the lock file is missing. Workaround Debian bug in pip (See #15 for details).","title":"0.4.3 (2018-11-06)"},{"location":"changelog/#042_2018-11-05","text":"Write some metadata inside the requirements.lock file. Improve dmenv run : Suggest running lock or install Do not crash if used without arguments","title":"0.4.2 (2018-11-05)"},{"location":"changelog/#041_2018-11-04","text":"Fix CI on Windows.","title":"0.4.1 (2018-11-04)"},{"location":"changelog/#040_2018-11-03","text":"dmenv no longer needs a configuration file. Find the Python interpreter to use by looking in the PATH environment variable.","title":"0.4.0 (2018-11-03)"},{"location":"changelog/#034_2018-11-03","text":"Fix #9 : If dmenv is run inside an existing virtual environment , just use it.","title":"0.3.4 (2018-11-03)"},{"location":"changelog/#033_2018-11-03","text":"Also upgrade pip when running dmenv install . Fix incorrect message when running dmenv lock .","title":"0.3.3 (2018-11-03)"},{"location":"changelog/#032_2018-11-03","text":"Fix regression introduced in 0.3.1: create config path parent subdirectory before trying to write inside it.","title":"0.3.2 (2018-11-03)"},{"location":"changelog/#031_2018-11-03","text":"Add a dmenv subdirectory to the configuration file path.","title":"0.3.1 (2018-11-03)"},{"location":"changelog/#030_2018-11-01","text":"Replace command freeze by lock .","title":"0.3.0 (2018-11-01)"},{"location":"changelog/#023_2018-11-01","text":"Add command dmenv init to generate a working setup.py file.","title":"0.2.3 (2018-11-01)"},{"location":"changelog/#022_2018-11-01","text":"Fix running dmenv on Windows. The configuration file is now read from $HOME ( ~/.config on Linux and macOS, %HOME%\\AppData\\Local on Windows).","title":"0.2.2 (2018-11-01)"},{"location":"changelog/#021_2018-10-31","text":"The .dmenv.toml file is now required.","title":"0.2.1 (2018-10-31)"},{"location":"changelog/#020_2018-10-31","text":"Can be used with multiple python versions, using the .dmenv.toml config file.","title":"0.2.0 (2018-10-31)"},{"location":"changelog/#010_2018-10-31","text":"Initial release.","title":"0.1.0 (2018-10-31)"},{"location":"faq/","text":"FAQ \u00b6 I'm on Debian, and I've got errors when running bdist_wheel \u00b6 This is an upstream bug . As a workaround, you can install virtual environment with python3 -m pip install virtual environment --user and then set the DMENV_NO_VENV_STDLIB environment variable to a non-empty value like 1 . Why Rust? \u00b6 Because it has excellent support for what we need: manipulate paths and run commands in a cross-platform way Because it's my second favorite language Because distribution is really easy Because by not using Python at all dmenv is less likely to break if something on your system changes.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#im_on_debian_and_ive_got_errors_when_running_bdist_wheel","text":"This is an upstream bug . As a workaround, you can install virtual environment with python3 -m pip install virtual environment --user and then set the DMENV_NO_VENV_STDLIB environment variable to a non-empty value like 1 .","title":"I'm on Debian, and I've got errors when running bdist_wheel"},{"location":"faq/#why_rust","text":"Because it has excellent support for what we need: manipulate paths and run commands in a cross-platform way Because it's my second favorite language Because distribution is really easy Because by not using Python at all dmenv is less likely to break if something on your system changes.","title":"Why Rust?"},{"location":"goodies/","text":"dmenv goodies \u00b6 dmenv also comes with a few commands for carrying out boring tasks. You can view the full list by running dmenv help , here are a few more details: dmenv run \u00b6 You can use: dmenv run to run any binary from the virtual environment. If the program you want to run needs command-line options, use a -- separator, like so: dmenv run -- pytest --collect-only dmenv upgrade-pip \u00b6 Tired of pip telling you to upgrade itself? Run dmenv upgrade-pip :) It's exactly the same as typing dmenv run -- python -m pip install --upgrade pip , but with less keystrokes :P dmenv show:venv_path \u00b6 dmenv show:venv_path shows the path of the current virtual environment. Nothing more, nothing less. dmenv show:bin_path \u00b6 dmenv show:bin_path shows the path of the virtual environment's binaries. You can use it in CI scripts like this: script: - dmenv install - export PATH=$(dmenv show:bin_path):$PATH dmenv show:deps \u00b6 Just a wrapper for pip list : $ dmenv show:deps Package Version ------------------ ------- atomicwrites 1.2.1 attrs 18.2.0 importlib-metadata 0.6 ... dmenv bump-in-lock \u00b6 You can use bump-in-lock to bump versions directly in the requirements.lock file: # contents of requirements.lock: bar==0.3 foo==1.2 $ dmenv bump-in-lock bar 0.4 # new contents: bar==0.4 foo==1.2 If you used a git URL in the requirements.lock file, you can also bump the git reference: # contents of requirements.lock: bar==0.3 foo==git@gitlab.com/foo/foo@master#egg=foo $ dmenv bump-in-lock --git foo deadbeef bar==0.3 foo==git@gitlab.com/foo/foo@deadbeef#egg=foo dmenv process-scripts \u00b6 If you set the DMENV_SCRIPTS_PATH environment variable to a writeable directory in your $PATH, you can run dmenv process-scripts in any project, and it will create a script there for all the \"console\" entry points defined in setup.cfg : $ export DMENV_SCRIPTS_PATH=$HOME/.local/bin $ cd foo-project $ cat foo/main.py def main(): print(\"Hello, this is foo\") $ cat setup.cfg [options.entry_points] console_scripts = foo=foo:main $ dmenv process-scripts $ There is now a file named `foo` in `~/.local/bin`, so this works: $ foo Hello, this is foo","title":"Goodies"},{"location":"goodies/#dmenv_goodies","text":"dmenv also comes with a few commands for carrying out boring tasks. You can view the full list by running dmenv help , here are a few more details:","title":"dmenv goodies"},{"location":"goodies/#dmenv_run","text":"You can use: dmenv run to run any binary from the virtual environment. If the program you want to run needs command-line options, use a -- separator, like so: dmenv run -- pytest --collect-only","title":"dmenv run"},{"location":"goodies/#dmenv_upgrade-pip","text":"Tired of pip telling you to upgrade itself? Run dmenv upgrade-pip :) It's exactly the same as typing dmenv run -- python -m pip install --upgrade pip , but with less keystrokes :P","title":"dmenv upgrade-pip"},{"location":"goodies/#dmenv_showvenv_path","text":"dmenv show:venv_path shows the path of the current virtual environment. Nothing more, nothing less.","title":"dmenv show:venv_path"},{"location":"goodies/#dmenv_showbin_path","text":"dmenv show:bin_path shows the path of the virtual environment's binaries. You can use it in CI scripts like this: script: - dmenv install - export PATH=$(dmenv show:bin_path):$PATH","title":"dmenv show:bin_path"},{"location":"goodies/#dmenv_showdeps","text":"Just a wrapper for pip list : $ dmenv show:deps Package Version ------------------ ------- atomicwrites 1.2.1 attrs 18.2.0 importlib-metadata 0.6 ...","title":"dmenv show:deps"},{"location":"goodies/#dmenv_bump-in-lock","text":"You can use bump-in-lock to bump versions directly in the requirements.lock file: # contents of requirements.lock: bar==0.3 foo==1.2 $ dmenv bump-in-lock bar 0.4 # new contents: bar==0.4 foo==1.2 If you used a git URL in the requirements.lock file, you can also bump the git reference: # contents of requirements.lock: bar==0.3 foo==git@gitlab.com/foo/foo@master#egg=foo $ dmenv bump-in-lock --git foo deadbeef bar==0.3 foo==git@gitlab.com/foo/foo@deadbeef#egg=foo","title":"dmenv bump-in-lock"},{"location":"goodies/#dmenv_process-scripts","text":"If you set the DMENV_SCRIPTS_PATH environment variable to a writeable directory in your $PATH, you can run dmenv process-scripts in any project, and it will create a script there for all the \"console\" entry points defined in setup.cfg : $ export DMENV_SCRIPTS_PATH=$HOME/.local/bin $ cd foo-project $ cat foo/main.py def main(): print(\"Hello, this is foo\") $ cat setup.cfg [options.entry_points] console_scripts = foo=foo:main $ dmenv process-scripts $ There is now a file named `foo` in `~/.local/bin`, so this works: $ foo Hello, this is foo","title":"dmenv process-scripts"},{"location":"installation/","text":"Installing dmenv \u00b6 Using the pre-compiled binaries \u00b6 The easiest way is to download the matching binary from the releases page for your platform and put it somewhere on in your $PATH. Linux, macOS \u00b6 cd ~/.local/bin curl --fail -L \\ https://github.com/TankerHQ/dmenv/releases/download/v0.20.0/dmenv-<platform> \\ -o dmenv chmod u+x dmenv Notes: Replace <platform> by your current platform: linux , or osx in the above command line. Make sure ~/.local/bin is in your PATH. Windows \u00b6 Download the dmenv-windows.exe from the release page and save it for instance in c:\\path\\to\\python\\Scripts\\dmenv.exe . (This directory should already be in you PATH if you used the default settings when installing Python). Installing from source \u00b6 If you prefer, you can also install rust and install dmenv with cargo install dmenv .","title":"Installation"},{"location":"installation/#installing_dmenv","text":"","title":"Installing dmenv"},{"location":"installation/#using_the_pre-compiled_binaries","text":"The easiest way is to download the matching binary from the releases page for your platform and put it somewhere on in your $PATH.","title":"Using the pre-compiled binaries"},{"location":"installation/#linux_macos","text":"cd ~/.local/bin curl --fail -L \\ https://github.com/TankerHQ/dmenv/releases/download/v0.20.0/dmenv-<platform> \\ -o dmenv chmod u+x dmenv Notes: Replace <platform> by your current platform: linux , or osx in the above command line. Make sure ~/.local/bin is in your PATH.","title":"Linux, macOS"},{"location":"installation/#windows","text":"Download the dmenv-windows.exe from the release page and save it for instance in c:\\path\\to\\python\\Scripts\\dmenv.exe . (This directory should already be in you PATH if you used the default settings when installing Python).","title":"Windows"},{"location":"installation/#installing_from_source","text":"If you prefer, you can also install rust and install dmenv with cargo install dmenv .","title":"Installing from source"}]}